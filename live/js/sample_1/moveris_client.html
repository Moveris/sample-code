<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Moveris Live - Optimized</title>
    <link rel="icon" href="./logo_small.png">
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background-color: #0c2f54;
            padding: 0;
        }
        
        .main-container {
            display: grid;
            grid-template-columns: 300px 1fr 350px;
            gap: 20px;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .column {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            height: fit-content;
        }
        
        .left-column, .middle-column, .right-column {
            min-height: 78vh;
        }
        
        h1 {
            color: #333;
            text-align: center;
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin: 20px auto;
        }
        
        h2, h3 {
            color: #333;
            margin: 0 0 15px 0;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
        }
        
        th, td {
            border: 1px solid #ddd;
            padding: 8px 10px;
            text-align: left;
        }
        
        th {
            background-color: #d1ecf1;
            font-weight: 600;
        }
        
        .config-section {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        
        .config-section label {
            display: block;
            margin: 10px 0 5px 0;
            font-weight: 600;
            color: #555;
            font-size: 14px;
        }
        
        .config-section input {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        
        .video-container {
            text-align: center;
            margin: 20px 0;
        }
        
        video {
            max-width: 100%;
            width: 100%;
            max-height: 360px;
            border: 2px solid #ddd;
            border-radius: 8px;
            background-color: #000;
        }
        
        .controls {
            text-align: center;
            margin: 20px 0;
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
        }
        
        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 15px 25px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            min-width: 180px;
            transition: all 0.3s ease;
        }
        
        button:hover:not(:disabled) {
            background-color: #0056b3;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        
        button:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
            opacity: 0.6;
        }
        
        .start-btn {
            background-color: #28a745;
        }
        
        .start-btn:hover:not(:disabled) {
            background-color: #218838;
        }
        
        .stop-btn {
            background-color: #dc3545;
        }
        
        .stop-btn:hover:not(:disabled) {
            background-color: #c82333;
        }
        
        .status {
            text-align: center;
            margin: 20px 0;
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
        }
        
        .status.connected { background-color: #d4edda; color: #155724; border: 2px solid #c3e6cb; }
        .status.disconnected { background-color: #f8d7da; color: #721c24; border: 2px solid #f5c6cb; }
        .status.connecting { background-color: #fff3cd; color: #856404; border: 2px solid #ffeaa7; }
        .status.authenticated { background-color: #d1ecf1; color: #0c5460; border: 2px solid #bee5eb; }
        .status.streaming { 
            background-color: #d4edda; 
            color: #155724; 
            border: 2px solid #c3e6cb;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        .stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin: 20px 0;
        }
        
        .stat-card, .performance-card {
            background: #e9ecef;
            padding: 10px;
            border-radius: 5px;
            text-align: center;
        }
        
        .stat-card h4, .performance-card h4 {
            margin: 0 0 5px 0;
            color: #495057;
            font-size: 12px;
        }
        
        .stat-value, .performance-value {
            font-size: 18px;
            font-weight: bold;
            color: #007bff;
        }
        
        .performance-card {
            background: #e7f3ff;
        }
        
        .performance-card h4 {
            color: #0056b3;
        }
        
        .performance-value {
            font-size: 16px;
            color: #0056b3;
        }
        
        .performance-stats {
            margin-top: 15px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 5px;
        }
        
        .performance-stats h4 {
            margin: 0 0 10px 0;
            font-size: 13px;
            color: #495057;
        }
        
        .perf-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }
        
        .logs {
            margin-top: 20px;
        }

        #logs {
            background-color: #1e1e1e;
            color: #00ff00;
            padding: 15px;
            border-radius: 5px;
            height: 200px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }
        
        .clear-logs {
            background-color: #6c757d;
            font-size: 12px;
            padding: 5px 10px;
            float: right;
            margin-bottom: 10px;
            min-width: auto;
        }
        
        /* Responsive design */
        @media (max-width: 1200px) {
            .main-container {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <h1><img width="200" src="./MoverisLiveLogo.png" alt="Moveris Live Logo"></h1>
    
    <div class="main-container">
        <!-- Left Column - Configuration -->
        <div class="column left-column">
            <div class="config-section">
                <h3>üîß Configuration</h3>
                
                <label for="secretKey">Secret Key:</label>
                <input type="password" id="secretKey" placeholder="Enter secret key" autocomplete="off">
                
                <label for="frameRate">Frame Rate (FPS):</label>
                <input type="number" id="frameRate" value="10" min="1" max="60">
                
                <label for="quality">Image Quality (0.1 - 1.0):</label>
                <input type="number" id="quality" value="0.7" min="0.1" max="1.0" step="0.1">
            </div>
            
            <div class="stats">
                <div class="stat-card">
                    <h4>Frames Sent</h4>
                    <div class="stat-value" id="framesSent">0</div>
                </div>
                <div class="stat-card">
                    <h4>Frames Ack'd</h4>
                    <div class="stat-value" id="serverBuffer">0</div>
                </div>
                <div class="stat-card">
                    <h4>Connection Time</h4>
                    <div class="stat-value" id="connectionTime">--:--</div>
                </div>
                <div class="stat-card">
                    <h4>Processing Status</h4>
                    <div class="stat-value" id="processingStatus">Idle</div>
                </div>
            </div>
            
            <div class="performance-stats">
                <h4>üìä Performance Metrics</h4>
                <div class="perf-grid">
                    <div class="performance-card">
                        <h4>Avg Send Time</h4>
                        <div class="performance-value" id="avgSendTime">--</div>
                    </div>
                    <div class="performance-card">
                        <h4>Avg ACK Time</h4>
                        <div class="performance-value" id="avgAckTime">--</div>
                    </div>
                    <div class="performance-card">
                        <h4>Actual FPS</h4>
                        <div class="performance-value" id="actualFps">--</div>
                    </div>
                    <div class="performance-card">
                        <h4>Process Time</h4>
                        <div class="performance-value" id="processTime">--</div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Middle Column - Video and Controls -->
        <div class="column middle-column">
            <div class="video-container">
                <video id="videoElement" autoplay muted playsinline>
                    Your browser does not support the video tag.
                </video>
            </div>
            
            <div class="controls">
                <button id="startStreamBtn" class="start-btn">
                    üöÄ Start Streaming
                </button>
                <button id="stopStreamBtn" disabled class="stop-btn">
                    ‚èπÔ∏è Stop & Disconnect
                </button>
            </div>
            
            <div id="status" class="status disconnected">
                üì° Status: Ready to start streaming
            </div>
        </div>
        
        <!-- Right Column - Predictions and Logs -->
        <div class="column right-column">
            <div class="predictions-section">
                <h2>Model Predictions</h2>
                <p>Latest predictions will be updated below.</p>

                <table id="predictionsTable">
                    <tbody id="resultBody">
                        <tr><th>Prediction</th><td>-</td></tr>
                        <tr><th>AI Probability</th><td>-</td></tr>
                        <tr><th>Confidence</th><td>-</td></tr>
                        <tr><th>Processing Time</th><td>-</td></tr>
                        <tr><th>Attention</th><td>-</td></tr>
                        <tr><th>Emotion</th><td>-</td></tr>
                        <tr><th>Received At</th><td>-</td></tr>
                    </tbody>
                </table>
            </div>
            
            <div class="logs">
                <button class="clear-logs" onclick="clearLogs()">Clear Logs</button>
                <div id="logs"></div>
            </div>
        </div>
    </div>

    <script>
        /**
         * OPTIMIZED VideoWebSocketClient Class
         * Performance improvements:
         * - Efficient frame queue management
         * - Reduced memory footprint
         * - Better error handling
         * - Optimized canvas operations
         */
        class VideoWebSocketClient {
            constructor(wsUrl, secretKey) {
                this.wsUrl = wsUrl;
                this.secretKey = secretKey;
                this.socket = null;
                this.stream = null;
                
                // Stats
                this.frameCount = 0;
                this.serverBufferSize = 0;
                this.connectionStartTime = null;
                this.isAuthenticated = false;
                
                // Performance tracking (use circular buffers for efficiency)
                this.frameSendTimes = new Map();
                this.ackTimes = this.createCircularBuffer(50);
                this.frameTimes = this.createCircularBuffer(50);
                
                // FPS tracking
                this.fpsCounter = 0;
                this.fpsStartTime = Date.now();
                
                // Canvas (reuse for efficiency)
                this.canvas = document.createElement('canvas');
                this.ctx = this.canvas.getContext('2d', { alpha: false });
                
                // Intervals
                this.streamingInterval = null;
                this.fpsInterval = null;
                this.lastFrameTime = null;
            }

            // Circular buffer for efficient memory management
            createCircularBuffer(size) {
                return {
                    data: [],
                    size: size,
                    add(value) {
                        this.data.push(value);
                        if (this.data.length > this.size) {
                            this.data.shift();
                        }
                    },
                    average() {
                        if (this.data.length === 0) return 0;
                        return this.data.reduce((a, b) => a + b, 0) / this.data.length;
                    },
                    clear() {
                        this.data = [];
                    }
                };
            }

            async connect() {
                return new Promise((resolve, reject) => {
                    try {
                        this.socket = new WebSocket(this.wsUrl);
                        this.connectionStartTime = Date.now();
                        
                        this.socket.onopen = () => {
                            console.log('‚úÖ WebSocket connected');
                            this.log('‚úÖ WebSocket connected');
                            updateStatus('Connected, authenticating...', 'connecting');
                            resolve();
                        };

                        this.socket.onmessage = (event) => {
                            try {
                                const data = JSON.parse(event.data);
                                this.handleMessage(data);
                            } catch (error) {
                                console.error('‚ùå Error parsing message:', error);
                            }
                        };

                        this.socket.onclose = (event) => {
                            console.log('üîå WebSocket closed:', event.code);
                            this.log(`üîå Disconnected: ${event.code}`);
                            updateStatus('Disconnected', 'disconnected');
                            this.cleanup();
                        };

                        this.socket.onerror = (error) => {
                            console.error('‚ùå WebSocket error:', error);
                            this.log('‚ùå Connection error');
                            updateStatus('Connection error', 'disconnected');
                            reject(error);
                        };

                    } catch (error) {
                        reject(error);
                    }
                });
            }

            handleMessage(data) {
                const receiveTime = Date.now();
                
                switch(data.type) {
                    case 'auth_required':
                        this.log('üîë Authentication required');
                        this.authenticate();
                        break;
                    
                    case 'auth_success':
                        this.log('‚úÖ Authenticated');
                        this.isAuthenticated = true;
                        updateStatus('Authenticated - Starting camera...', 'authenticated');
                        setTimeout(() => this.startCamera(), 500);
                        break;
                    
                    case 'frame_received':
                        this.handleFrameAck(data, receiveTime);
                        break;
                    
                    case 'processing_started':
                        this.log(`üîÑ ${data.message}`);
                        this.updateProcessingStatus('Processing', '#856404', '#fff3cd');
                        break;
                    
                    case 'processing_complete':
                        this.log(`‚úÖ Processed ${data.frames_processed} frames`);
                        this.updateResults(data.result);
                        this.updateProcessingStatus('Complete', '#155724', '#d4edda');
                        setTimeout(() => {
                            this.updateProcessingStatus('Idle', '#007bff', 'transparent');
                        }, 3000);
                        break;
                    
                    case 'error':
                        console.error('‚ùå Server error:', data.message);
                        this.log(`‚ùå Error: ${data.message}`);
                        this.displayError(data.message);
                        break;

                    case 'disconnect':
                        this.log(`‚ö†Ô∏è Disconnect reason: ${data.reason}`);
                        this.disconnect();
                        break;
                }
            }

            handleFrameAck(data, receiveTime) {
                const frameNum = data.frame_number;
                
                // Calculate ACK latency
                if (this.frameSendTimes.has(frameNum)) {
                    const sendTime = this.frameSendTimes.get(frameNum);
                    const ackLatency = receiveTime - sendTime;
                    this.ackTimes.add(ackLatency);
                    this.frameSendTimes.delete(frameNum);
                    
                    // Update UI less frequently (every 10 frames)
                    if (frameNum % 10 === 0) {
                        document.getElementById('avgAckTime').textContent = 
                            `${this.ackTimes.average().toFixed(0)}ms`;
                    }
                }
                
                // Update server buffer
                this.serverBufferSize = data.total_frames || 0;
                document.getElementById('serverBuffer').textContent = this.serverBufferSize;
                
                // Log less frequently (every 100 frames)
                if (frameNum % 100 === 0) {
                    this.log(`üìä Frame ${frameNum} ACK. Buffer: ${this.serverBufferSize}`);
                }
            }

            updateProcessingStatus(status, color, bgColor) {
                const el = document.getElementById('processingStatus');
                el.textContent = status;
                el.style.color = color;
                el.style.backgroundColor = bgColor;
                el.style.padding = bgColor !== 'transparent' ? '5px 10px' : '0';
                el.style.borderRadius = '4px';
                el.style.fontWeight = 'bold';
            }

            updateResults(result) {
                const tbody = document.getElementById("resultBody");
                
                if (result.prediction === 'Error' || result.processing_error) {
                    tbody.innerHTML = `
                        <tr><th>Status</th><td style="color: red;">Error</td></tr>
                        <tr><th>Message</th><td style="color: red;">${result.processing_error || 'Unknown'}</td></tr>
                        <tr><th>Received At</th><td>${new Date().toLocaleString()}</td></tr>
                    `;
                } else {
                    const color = result.prediction === 'AI' ? 'red' : 'green';
                    tbody.innerHTML = `
                        <tr><th>Prediction</th><td style="color: ${color}; font-weight: bold;">${result.prediction}</td></tr>
                        <tr><th>AI Probability</th><td>${(result.ai_probability * 100).toFixed(2)}%</td></tr>
                        <tr><th>Confidence</th><td>${result.confidence.toFixed(4)}</td></tr>
                        <tr><th>Processing Time</th><td>${result.processing_time_seconds.toFixed(2)}s</td></tr>
                        <tr><th>Attention</th><td>${result.ai_attention_level || '-'}</td></tr>
                        <tr><th>Emotion</th><td>${result.ai_emotion_level || '-'}</td></tr>
                        <tr><th>Received At</th><td>${new Date().toLocaleString()}</td></tr>
                    `;
                    
                    document.getElementById('processTime').textContent = 
                        `${result.processing_time_seconds.toFixed(2)}s`;
                }
            }

            displayError(message) {
                const tbody = document.getElementById("resultBody");
                tbody.innerHTML = `
                    <tr><th>Status</th><td style="color: red;">Error</td></tr>
                    <tr><th>Message</th><td style="color: red; font-size: 11px;">${message}</td></tr>
                    <tr><th>Received At</th><td>${new Date().toLocaleString()}</td></tr>
                `;
            }

            authenticate() {
                if (this.socket?.readyState === WebSocket.OPEN) {
                    this.socket.send(JSON.stringify({
                        type: 'auth',
                        token: this.secretKey
                    }));
                    this.log('üîë Authenticating...');
                }
            }

            async startCamera() {
                try {
                    const frameRate = parseInt(document.getElementById('frameRate').value);
                    
                    this.stream = await navigator.mediaDevices.getUserMedia({
                        video: {
                            width: { ideal: 640 },
                            height: { ideal: 480 },
                            frameRate: { ideal: frameRate }
                        },
                        audio: false
                    });

                    const video = document.getElementById('videoElement');
                    video.srcObject = this.stream;
                    
                    this.log('üì∑ Camera started');
                    updateStatus('Streaming...', 'streaming');
                    
                    document.getElementById('stopStreamBtn').disabled = false;
                    
                    this.startFrameCapture();
                    this.startFpsCounter();

                } catch (error) {
                    console.error('‚ùå Camera error:', error);
                    this.log(`‚ùå Camera: ${error.message}`);
                    
                    const errorMessages = {
                        'NotAllowedError': 'Camera access denied',
                        'NotFoundError': 'No camera found',
                    };
                    
                    const message = errorMessages[error.name] || error.message;
                    updateStatus(message, 'disconnected');
                    alert(`‚ùå ${message}`);
                    throw error;
                }
            }

            startFrameCapture() {
                const frameRate = parseInt(document.getElementById('frameRate').value);
                const frameInterval = 1000 / frameRate;
                let lastCaptureTime = Date.now();
                
                this.streamingInterval = setInterval(() => {
                    const now = Date.now();
                    const elapsed = now - lastCaptureTime;
                    
                    if (this.lastFrameTime) {
                        this.frameTimes.add(elapsed);
                        
                        // Update UI less frequently
                        if (this.frameCount % 10 === 0) {
                            document.getElementById('avgSendTime').textContent = 
                                `${this.frameTimes.average().toFixed(0)}ms`;
                        }
                    }
                    
                    this.captureAndSendFrame();
                    lastCaptureTime = now;
                    this.lastFrameTime = now;
                }, frameInterval);

                this.log(`üé• Capturing at ${frameRate} FPS`);
            }

            startFpsCounter() {
                this.fpsInterval = setInterval(() => {
                    const elapsed = (Date.now() - this.fpsStartTime) / 1000;
                    const fps = this.fpsCounter / elapsed;
                    
                    document.getElementById('actualFps').textContent = fps.toFixed(1);
                    
                    // Reset every 5 seconds
                    if (elapsed >= 5) {
                        this.fpsCounter = 0;
                        this.fpsStartTime = Date.now();
                    }
                }, 1000);
            }

            captureAndSendFrame() {
                if (!this.socket || !this.isAuthenticated) return;

                try {
                    const video = document.getElementById('videoElement');
                    
                    // Set canvas size (only if changed)
                    if (this.canvas.width !== video.videoWidth || 
                        this.canvas.height !== video.videoHeight) {
                        this.canvas.width = video.videoWidth || 640;
                        this.canvas.height = video.videoHeight || 480;
                    }

                    // Draw frame
                    this.ctx.drawImage(video, 0, 0, this.canvas.width, this.canvas.height);

                    // Convert to JPEG
                    const quality = parseFloat(document.getElementById('quality').value);
                    const base64Data = this.canvas.toDataURL('image/jpeg', quality).split(',')[1];

                    this.sendFrame(base64Data);
                    this.fpsCounter++;

                } catch (error) {
                    console.error('‚ùå Capture error:', error);
                    if (this.frameCount % 100 === 0) {
                        this.log(`‚ùå Capture error: ${error.message}`);
                    }
                }
            }

            sendFrame(frameData) {
                if (this.socket?.readyState === WebSocket.OPEN && this.isAuthenticated) {
                    this.frameCount++;
                    const sendTime = Date.now();
                    
                    // Track send time
                    this.frameSendTimes.set(this.frameCount, sendTime);
                    
                    // Clean up old entries (keep last 1000)
                    if (this.frameSendTimes.size > 1000) {
                        const keysToDelete = Array.from(this.frameSendTimes.keys())
                            .slice(0, this.frameSendTimes.size - 1000);
                        keysToDelete.forEach(key => this.frameSendTimes.delete(key));
                    }
                    
                    this.socket.send(JSON.stringify({
                        type: 'frame',
                        frame_number: this.frameCount,
                        frame_data: frameData,
                        timestamp: sendTime / 1000
                    }));
                    
                    document.getElementById('framesSent').textContent = this.frameCount;
                    return true;
                }
                return false;
            }

            disconnect() {
                this.cleanup();
                this.log('‚èπÔ∏è Disconnected');
            }

            cleanup() {
                // Stop intervals
                if (this.streamingInterval) {
                    clearInterval(this.streamingInterval);
                    this.streamingInterval = null;
                }
                
                if (this.fpsInterval) {
                    clearInterval(this.fpsInterval);
                    this.fpsInterval = null;
                }

                // Stop camera
                if (this.stream) {
                    this.stream.getTracks().forEach(track => track.stop());
                    this.stream = null;
                }

                const video = document.getElementById('videoElement');
                if (video.srcObject) {
                    video.srcObject = null;
                }

                // Close socket
                if (this.socket) {
                    this.socket.close();
                    this.socket = null;
                }
                
                this.resetStats();
            }

            resetStats() {
                this.frameCount = 0;
                this.serverBufferSize = 0;
                this.isAuthenticated = false;
                this.connectionStartTime = null;
                this.frameTimes.clear();
                this.ackTimes.clear();
                this.frameSendTimes.clear();
                this.fpsCounter = 0;
                this.fpsStartTime = Date.now();
                
                // Reset UI
                document.getElementById('framesSent').textContent = '0';
                document.getElementById('serverBuffer').textContent = '0';
                document.getElementById('connectionTime').textContent = '--:--';
                document.getElementById('avgSendTime').textContent = '--';
                document.getElementById('avgAckTime').textContent = '--';
                document.getElementById('actualFps').textContent = '--';
                document.getElementById('processTime').textContent = '--';
                this.updateProcessingStatus('Idle', '#007bff', 'transparent');
                
                document.getElementById('startStreamBtn').disabled = false;
                document.getElementById('stopStreamBtn').disabled = true;
            }

            log(message) {
                const timestamp = new Date().toLocaleTimeString();
                const logElement = document.getElementById('logs');
                logElement.insertAdjacentHTML("beforeend", `[${timestamp}] ${message}<br>`);
                logElement.scrollTop = logElement.scrollHeight;
                
                // Limit log size (keep last 100 entries)
                const entries = logElement.querySelectorAll('br');
                if (entries.length > 100) {
                    const toRemove = entries.length - 100;
                    for (let i = 0; i < toRemove; i++) {
                        logElement.removeChild(logElement.firstChild);
                    }
                }
            }
        }
        
        // Global state
        let client = null;
        let connectionTimer = null;

        function updateStatus(message, type = 'disconnected') {
            const el = document.getElementById('status');
            el.textContent = `üì° Status: ${message}`;
            el.className = `status ${type}`;
        }

        function updateConnectionTimer() {
            if (client?.connectionStartTime) {
                const elapsed = Math.floor((Date.now() - client.connectionStartTime) / 1000);
                const minutes = Math.floor(elapsed / 60);
                const seconds = elapsed % 60;
                document.getElementById('connectionTime').textContent = 
                    `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }
        }

        async function startStreaming() {
            try {
                const secretKey = document.getElementById('secretKey').value.trim();

                if (!secretKey) {
                    alert('Please enter your Secret Key');
                    return;
                }

                updateStatus('Connecting...', 'connecting');
                document.getElementById('startStreamBtn').disabled = true;

                const wsUrl = "wss://developers.moveris.com/ws/live/v1/";
                client = new VideoWebSocketClient(wsUrl, secretKey);
                
                await client.connect();
                
                connectionTimer = setInterval(updateConnectionTimer, 1000);

            } catch (error) {
                console.error('Failed to start:', error);
                client?.log(`‚ùå Failed: ${error.message}`);
                updateStatus('Failed to start', 'disconnected');
                document.getElementById('startStreamBtn').disabled = false;
                
                if (client) {
                    client.disconnect();
                    client = null;
                }
            }
        }

        function stopStreaming() {
            if (client) {
                client.disconnect();
                client = null;
            }

            if (connectionTimer) {
                clearInterval(connectionTimer);
                connectionTimer = null;
            }

            updateStatus('Ready to start streaming', 'disconnected');
        }

        function clearLogs() {
            document.getElementById('logs').innerHTML = '';
        }

        // Event listeners
        document.getElementById('startStreamBtn').addEventListener('click', startStreaming);
        document.getElementById('stopStreamBtn').addEventListener('click', stopStreaming);
        window.addEventListener('beforeunload', stopStreaming);

        // Initialize
        updateStatus('Ready to start streaming', 'disconnected');
    </script>
</body>
</html>
